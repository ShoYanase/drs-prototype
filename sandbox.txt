図26、図27より、バッファサイズが大きくなる程実行時間が短くなることがわかる。さらに、それぞれの近似曲線より、バッファサイズをx、実行時間をyとすると、両者の関係はy=a/x(aはある特定の定数)という方程式で近似的に表せることができ、実行時間はバッファサイズに反比例していることがわかる。また図27より、read、writeによる実装よりも、fread、fwriteによる実装の方が実行時間が速いことがわかる。実行時間がバッファサイズに反比例したのは、次のような理由が考えられる。cでは、ファイルの内容がバッファサイズごとに読み取り・書き込みが行われる。その処理の回数はバッファサイズに反比例する。よって読み取り・書き込みの回数が増えることによって実行時間が増えると考えられる。read、writeによる実装よりも、fread、fwriteによる実装の方が実行時間が速いのには、以下のような理由が考えられる。cは、両者とも同じバッファサイズで実行しているが、システムコールread、write関数の呼び出し回数が大きく違う。これによって両者の実行時間の違いが出ていると考えられる。

本実験の検証から各プログラムの性能差の原因について仮説を立てる。 仮説としては「バッファサイズが小さい(実行結果ではバッファサイズが500前後)場合ファイルコピー性能はfread, fwriteプログラムの方がread, writeプログラムより高く, 逆にバッファサイズが大きい(実行結果ではバッファサイズが600以上)場合ファイルコピー性能はread, writeプログラムの方がfread, fwriteプログラムより高くなっていく」というものが考えられる。  上記の仮説を支持する証拠は二点ある。
一点目はグラフ1からわかる通り, read, writeがfread, fwriteに比して変化率が大きく, また実行結果1と実行結果2から見て取れるように, 特定のバッファサイズで前者の計測時間が後者のそれを下回ることが確認できる点である。 したがって, 実行結果から読み取れるread, writeとfread, fwriteの性能差は仮説の通りであると言える。
二点目はreadやwriteのようなシステムコールと, freadやfwriteのようなシステムコールを使わないstdio.hのライブラリとの違いによる点である。 システムコールという機能に関しては, 「システムコールは簡単に実行速度を引き上げる秘密の関数というものではない（ただし、処理の高速化に役立つものもある）。基本的には、システムコールを呼び出さない方がプログラムの実行速度は速くなる」(3)とされる通りである。 readやwriteといったシステムコールは単にそのままではバッファリングを行わないため1バイトごとのデータ読み込みや書き込みを連続で行うことになり, 対してfreadやfwriteといった標準ライブラリはそれに定義されたバッファサイズでバッファリングを自動に行う。 以上より, バッファリングを意図的に行わない場合は標準ライブラリの方がシステムコールより高速に処理をすることができる。 しかし, freadとfwriteに定義されたバッファリングによる読み書き一処理分のバッファサイズ(本実験の実行結果から想定されるサイズは512B)に対し, それを上回るサイズのバッファリングが意図的に行われた場合, 定義されたバッファサイズ毎にファイルコピーを繰り返すという処理が発生するために, 実行時間が増大するのである。
したがって, システムコールにおいて適切にバッファリングを行った結果得られたバッファサイズが, 標準ライブラリで定義されているバッファサイズを上回る状態になるために本実験の実行結果が得られ, それらが仮説を支持する証拠であると考えられる。